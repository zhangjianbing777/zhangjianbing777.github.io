<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在谷歌上百度</title>
  
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-13T14:30:33.924Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BigBing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>还在使用BeanUtils？</title>
    <link href="http://yoursite.com/daily/beanutils.html"/>
    <id>http://yoursite.com/daily/beanutils.html</id>
    <published>2020-03-11T00:14:42.000Z</published>
    <updated>2020-03-13T14:30:33.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从名字上来看，BeanUtils是一个很好用的工具类。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;从名字上来看，BeanUtils是一个很好用的工具类。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="daily" scheme="http://yoursite.com/categories/daily/"/>
    
    
      <category term="daily" scheme="http://yoursite.com/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>2020特殊的一年</title>
    <link href="http://yoursite.com/life/my2020.html"/>
    <id>http://yoursite.com/life/my2020.html</id>
    <published>2020-03-09T15:04:42.000Z</published>
    <updated>2020-03-13T14:30:30.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020年真是特殊的一年，它是一个闰年</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2020年真是特殊的一年，它是一个闰年&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码分析：@Autowired注解原理分析</title>
    <link href="http://yoursite.com/spring/spring-autowired.html"/>
    <id>http://yoursite.com/spring/spring-autowired.html</id>
    <published>2019-03-05T13:53:00.000Z</published>
    <updated>2020-03-13T14:31:44.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>关于@Autowired这个注解，我们再熟悉不过了，经常跟@Resource来做对比，这篇文章我们不讨论两者有何异同，仅分析@Autowired的原理（基于Spring5）。</strong></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>假如一个接口(IUserService)有两个实现类，分别是(UserServiceImpl01)和(UserServiceImpl02)，在我们给类注入的时候，这样写(@Autowired private IUserService userService)会发生什么情况？答案肯定是报错，那么原理呢？文字描述：因为首先@Autowired是按照类型注入的，也就是.class，但UserServiceImpl01和UserServiceImpl02都是IUserService类型的，于是Spring就会按照后面的名字(userService)在容器中查找，但发现根本没有这个名字，因为两个实现类在不指定名字情况下，就是首字母小写的类名，然后抛出异常：expected single matching bean but found 2。。。</p><h1 id="如何解决这类问题"><a href="#如何解决这类问题" class="headerlink" title="如何解决这类问题"></a>如何解决这类问题</h1><ol><li>如果有两个实现类，还要使用@Autowired注解，可以将userService改成我们指定的实现类名称，比如UserServiceImpl01，或者不想改userService，可以加@Qualifier(value = “userServiceImpl01”)，指定需要注入的实现类。</li><li>使用@Resource注解，手动指定实现类名称。</li></ol><p><strong>还有很多种方法，但基本思想都一样，无非就是如何区分两个同祖宗的儿子，既然根儿相同，那就只有指定名字了。</strong></p><h1 id="Autowired原理"><a href="#Autowired原理" class="headerlink" title="@Autowired原理"></a>@Autowired原理</h1><p>提到@Autowired我们一般都知道叫依赖注入</p><ol><li>什么是依赖注入？</li><li>什么是注入，注到哪里？</li><li>什么时候注入的？<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2></li></ol><p><strong>依赖注入：Dependency Injection，简称DI，说白了就是利用反射机制为类的属性赋值的操作。</strong></p><h2 id="什么是注入，注入到哪里？"><a href="#什么是注入，注入到哪里？" class="headerlink" title="什么是注入，注入到哪里？"></a>什么是注入，注入到哪里？</h2><p><strong>注入就是为某个对象的外部资源赋值，注入某个对象所需要的外部资源（包括对象、资源、常量数据等）。IOC容器注入应用程序某个对象，应用程序所依赖的对象。</strong></p><h2 id="什么时候注入的？"><a href="#什么时候注入的？" class="headerlink" title="什么时候注入的？"></a>什么时候注入的？</h2><p><strong>在完成对象的创建，为对象变量进行赋值的时候进行注入（populate）。</strong></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>1.首先点开@Autowired，注释上写Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor，让我们去查阅这个类，看一下这个类的继承关系树，如下所示，可见它间接实现InstantiationAwareBeanPostProcessor，就具备了实例化前后(而不是初始化前后)管理对象的能力，实现了BeanPostProcessor，具有初始化前后管理对象的能力，实现BeanFactoryAware，具备随时拿到BeanFactory的能力，也就是说，这个AutowiredAnnotationBeanPostProcessor具备一切后置处理器的能力。<br><img src="https://image.nmyswls.com/nmyswls/article/image/20190130133909878" alt="请输入图片描述"><br>2.容器在初始化的时候，后置处理器的初始化要优先于剩下自定义Bean(比如我们自定义的Service，Controller等等)的初始化的，我们自定义的Bean初始化是在finishBeanFactoryInitialization(beanFactory)这里完成的，来到AbstractApplicationContext的refresh()方法。<br>3.finishBeanFactoryInitialization(beanFactory) –&gt; beanFactory.preInstantiateSingletons() –&gt; getBean(beanName) –&gt; doGetBean(beanName) –&gt; 来到AbstractBeanFactory第317行createBean(beanName, mbd, args)，来创建bean实例 –&gt; 来到AbstractAutowireCapableBeanFactory第503行doCreateBean(beanName, mbdToUse, args) –&gt; 紧接着来到AbstractAutowireCapableBeanFactory的第543行，instanceWrapper = createBeanInstance(beanName, mbd, args)就已经把Bean实例创建出来了，只不过instanceWrapper是一个被包装过了的bean，它里面的属性还未赋实际值 –&gt; 然后来到第555行applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)，这一步的作用就是将所有的后置处理器拿出来，并且把名字叫beanName的类中的变量都封装到InjectionMetadata的injectedElements集合里面，目的是以后从中获取，挨个创建实例，通过反射注入到相应类中。<br><img src="https://image.nmyswls.com/nmyswls/article/image/20190130143035776" alt="请输入图片描述"><br>4.紧接着来到AbstractAutowireCapableBeanFactory第588行populateBean(beanName, mbd, instanceWrapper)<br> –&gt; 点进去，来到AbstractAutowireCapableBeanFactory的第1347行，来循环遍历所有的后置处理器for (BeanPostProcessor bp : getBeanPostProcessors())，从方法名字postProcessPropertyValues也能看出来，就是给属性赋值，当bp是AutowiredAnnotationBeanPostProcessor的时候，进入postProcessPropertyValues方法，来到AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues方法，如下所示，首先找到需要注入的哪些元数据，然后metadata.inject（注入），注入方法点进去，来到InjectionMetadata的inject方法，在一个for循环里面依次执行element.inject(target, beanName, pvs)，来对属性进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.进入element.inject(target, beanName, pvs)，注意，这里必须要debug才可以进入真正的方法。来到AutowiredAnnotationBeanPostProcessor的inject方法，第584行，value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter)，由工厂解析这个依赖，进入，来到DefaultListableBeanFactory第1065行，result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter)再次解析依赖，点击进入，来到DefaultListableBeanFactory的doResolveDependency()方法，前面是一堆判断，比较，查看属性类型，这种类型的有几个(matchingBeans)，如果只有一个匹配，那么来到第1138行，instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this)，进入这个方法，可以看到就是前面说的根据工厂来创建实例的过程了：beanFactory.getBean(beanName)，其中这个beanName就是属性的名称，当经过一系列操作完成属性的实例化后，便来到AutowiredAnnotationBeanPostProcessor的第611行，利用反射为此对象赋值。这样，对象的创建以及赋值就完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>在容器启动，为对象赋值的时候，遇到@Autowired注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是Autowired的原理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;关于@Autowired这个注解，我们再熟悉不过了，经常跟@Resource来做对比，这篇文章我们不讨论两者有何异同，仅分析
      
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码分析：Spring的循环依赖分析</title>
    <link href="http://yoursite.com/spring/spring-loop.html"/>
    <id>http://yoursite.com/spring/spring-loop.html</id>
    <published>2019-03-04T13:57:00.000Z</published>
    <updated>2020-03-13T14:31:08.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ol start="0"><li>基于Spring5+</li><li>什么是循环依赖？</li><li>循环依赖有几种？</li><li>Spring可以解决哪几种，为什么不能解决这几种？</li><li>Spring是如何判断存在循环依赖的？<h1 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h1></li></ol><blockquote><p><strong>什么是循环依赖？我们都知道Spring最大的作用就是来替我们管理Bean的，当然也包括Bean的创建以及整个生命周期，但是有这么一种情况，假设有三个类A、B、C需要交给Spring来管理，但A实例的创建需要先有B实例，而B实例的创建需要先有C实例，C实例的创建需要先有A实例，这样三个类就自然形成了一个环状结构，如果用代码来表示，如下：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    TestB testB;</span><br><span class="line">    get;</span><br><span class="line">    set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    TestC testC;</span><br><span class="line">    get;</span><br><span class="line">    set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line">    TestA testA;</span><br><span class="line">    get;</span><br><span class="line">    set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这样，三个类就彼此形成了一个环状，那么Spring是如何来处理这样的状况呢？</strong></p></blockquote><h1 id="循环依赖有几种？"><a href="#循环依赖有几种？" class="headerlink" title="循环依赖有几种？"></a>循环依赖有几种？</h1><blockquote><p><strong>有三种情况：</strong></p></blockquote><ol><li>基于构造方法的循环依赖</li><li>基于setter构造的循环依赖(网上也叫field属性依赖)</li><li>基于prototype范围的依赖</li></ol><h1 id="Spring可以解决哪些循环依赖，为什么？"><a href="#Spring可以解决哪些循环依赖，为什么？" class="headerlink" title="Spring可以解决哪些循环依赖，为什么？"></a>Spring可以解决哪些循环依赖，为什么？</h1><p><strong>首先说一下结论：除了第二种Spring可以帮我们解决，其它两种都不能解决。我们知道Spring为我们完全实例化好一个Bean一定会经过一下三步：</strong></p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象。</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充。</li><li>initializeBean：调用默认的或者自定义的init方法。</li></ol><p><strong>循环依赖的产生定会发生在步骤1和2中，因为1是利用构造方法，2是利用属性赋值。</strong></p><h2 id="基于构造方法的循环依赖"><a href="#基于构造方法的循环依赖" class="headerlink" title="基于构造方法的循环依赖"></a>基于构造方法的循环依赖</h2><blockquote><p><strong>先说结论基于构造器的循环依赖Spring是无法解决的，是因为没有加入提前曝光的集合中，加入集合的条件是已经创建了Bean的包装对象，而构造注入的时候，并没有完成对象的创建，下面会有代码说明。</strong></p></blockquote><p>测试用例：</p><p>xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testA"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopA"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"testB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testB"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopB"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"testC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testC"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopC"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"testA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:测试通过有参构造方式注入产生的循环依赖问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 70KG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test02.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上面代码：</p><ol><li>Spring容器创建testA的Bean实例，首先去”当前创建Bean池”，查找是否当前Bean正在创建，如果没发现，则继续准备其需要的构造器参数testB，并将testA标识符放到”当前创建Bean池”。</li><li>Spring容器创建testB的Bean实例，首先去”当前创建Bean池”，查找是否当前Bean正在创建，如果没发现，则继续准备其需要的构造器参数testC，并将testB标识符放到”当前创建Bean池”。</li><li>Spring容器创建testC的Bean实例，首先去”当前创建Bean池”，查找是否当前Bean正在创建，如果没发现，则继续准备其需要的构造器参数testA，并将testC标识符放到”当前创建Bean池”。</li><li>到此为止Spring容器要去创建testA，但发现该Bean的标志符在”当前创建Bean池”中，表示了循环依赖，于是抛出BeanCurrentlyInCreationException异常。</li></ol><p>其中”当前创建Bean池”就是一个Set集合，DefaultSingletonBeanRegistry类中beforeSingletonCreation方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>然后我们来到创建Bean实例的地方：</strong></p></blockquote><p>AbstractAutowireCapableBeanFactory类的543行，通过这个方法返回一个这个Bean的包装对象：</p><p>–&gt; instanceWrapper = createBeanInstance(beanName, mbd, args);—-&gt; 进入这个方法</p><p>–&gt; AbstractAutowireCapableBeanFactory类的1129行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line"><span class="comment">// 需要确定构造函数，也就是说构造方法的循环依赖会在这儿return</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="comment">// 无需特殊处理，仅使用无参构造即可，setter的循环依赖会在这个地方return</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure><p><strong>在上面代码中返回Bean的包装对象下面紧接着才是将这个对象曝光，也就是加入到SingletonFactory集合中，所以构造方法的循环引用，Spring是无法解决的，来到AbstractAutowireCapableBeanFactory的574行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure><h2 id="基于setter构造的循环依赖"><a href="#基于setter构造的循环依赖" class="headerlink" title="基于setter构造的循环依赖"></a>基于setter构造的循环依赖</h2><blockquote><p><strong>首先说结论：Spring是可以为我们解决这样的依赖的，原理说白了就是用了缓存处理，也就是常说的提前曝光，为什么叫提前曝光呢？因为这个缓存中的Bean是一个还未进行赋值的Bean，仅仅是一个引用而已。</strong></p></blockquote><p>xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testA"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopA"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loopB"</span> <span class="attr">ref</span>=<span class="string">"testB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testB"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopB"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loopC"</span> <span class="attr">ref</span>=<span class="string">"testC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testC"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopC"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loopA"</span> <span class="attr">ref</span>=<span class="string">"testA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:通过setter注入产生的循环依赖问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 70KG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test03.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ol><li>Spring容器创建单例”loopA”，首先根据无参构造创建Bean，并暴露到Map(singletonFactories)中，并将”loopA”标志符放到当前创建正在创建的Bean池(singletonsCurrentlyInCreation)中，然后进行setter注入”loopB”。</li><li>Spring容器创建单例”loopB”，首先根据无参构造创建Bean，并暴露到Map(singletonFactories)中，并将”loopA”标志符放到当前创建正在创建的Bean池(singletonsCurrentlyInCreation)中，然后进行setter注入”loopC”。</li><li>Spring容器创建单例”loopC”，首先根据无参构造创建Bean，并暴露到Map(singletonFactories)中，并将”loopA”标志符放到当前创建正在创建的Bean池(singletonsCurrentlyInCreation)中，然后进行setter注入”loopA”。在注入”loopA”的时候，由于提前暴露在singletonFactories集合中了，利用它就可以取到”loopA”正在创建的Bean对象。</li><li>最后依赖注入”testB”，”testA”，完成setter注入。</li></ol><p><strong>查看控制台输出日志：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正在创建testA对象</span></span><br><span class="line">Creating shared instance of singleton bean <span class="string">'testA'</span></span><br><span class="line">Creating instance of bean <span class="string">'testA'</span></span><br><span class="line"><span class="comment">// 在缓存早期引用，目的是防止循环引用问题</span></span><br><span class="line">Eagerly caching bean <span class="string">'testA'</span> to allow <span class="keyword">for</span> resolving potential circular references</span><br><span class="line">Creating shared instance of singleton bean <span class="string">'testB'</span></span><br><span class="line">Creating instance of bean <span class="string">'testB'</span></span><br><span class="line">Eagerly caching bean <span class="string">'testB'</span> to allow <span class="keyword">for</span> resolving potential circular references</span><br><span class="line">Creating shared instance of singleton bean <span class="string">'testC'</span></span><br><span class="line">Creating instance of bean <span class="string">'testC'</span></span><br><span class="line">Eagerly caching bean <span class="string">'testC'</span> to allow <span class="keyword">for</span> resolving potential circular references</span><br><span class="line"><span class="comment">// 在创建testC的时候会去缓存中拿原来存储的testA，并返回，但此时的testA是一个不完全的对象，也就是尚未初始化</span></span><br><span class="line">Returning eagerly cached instance of singleton bean <span class="string">'testA'</span> that is not fully initialized yet - a consequence of a circular reference</span><br><span class="line"><span class="comment">// 紧接着完成C的创建，顺便其它的也完成了</span></span><br><span class="line">Finished creating instance of bean <span class="string">'testC'</span></span><br><span class="line">Finished creating instance of bean <span class="string">'testB'</span></span><br><span class="line">Finished creating instance of bean <span class="string">'testA'</span></span><br><span class="line">Returning cached instance of singleton bean <span class="string">'testB'</span></span><br><span class="line">Returning cached instance of singleton bean <span class="string">'testC'</span></span><br></pre></td></tr></table></figure><p><strong>基于setter的循环依赖利用了提前曝光机制，这一步的关键代码，在AbstractAutowireCapableBeanFactory的574行，代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure><p><strong>在加入SingletonFactory的前提是此Bean已经创建出来，才能够加入到这个Map集合中，也就是提前曝光，可以让别的Bean在初始化的时候从中拿到。否则是没有机会加入到Map中的。</strong></p><h2 id="基于prototype范围的依赖"><a href="#基于prototype范围的依赖" class="headerlink" title="基于prototype范围的依赖"></a>基于prototype范围的依赖</h2><blockquote><p><strong>首先说结论，对于多例情况下的循环依赖，是无法解决的，因为Spring容器不进行缓存，更无法提前暴露。</strong></p></blockquote><p>测试用例：</p><p>xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testA"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopA"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loopB"</span> <span class="attr">ref</span>=<span class="string">"testB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testB"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopB"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loopC"</span> <span class="attr">ref</span>=<span class="string">"testC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testC"</span> <span class="attr">class</span>=<span class="string">"com.nmys.story.springCore.loop_dependency.loop01.LoopC"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loopA"</span> <span class="attr">ref</span>=<span class="string">"testA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:通过setter注入产生的循环依赖问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 70KG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test03.xml"</span>);</span><br><span class="line">        LoopA loopA = context.getBean(LoopA<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(loopA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>会抛出BeanCurrentlyInCreationException异常。</strong></p><h1 id="Spring是如何检测循环依赖"><a href="#Spring是如何检测循环依赖" class="headerlink" title="Spring是如何检测循环依赖"></a>Spring是如何检测循环依赖</h1><p><strong>来到AbstractBeanFactory的246行，代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName);</span><br></pre></td></tr></table></figure><p><strong>这一步是从缓存中获取以前创建的实例，如果发现存在，那么就存在循环依赖。</strong></p><p>到此，全文完，自我感觉比其他的整理还算详细，如有疑问，请留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;基于Spring5+&lt;/li&gt;
&lt;li&gt;什么是循环依赖？&lt;/li&gt;
&lt;li&gt;循环依赖有几种？&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
</feed>
